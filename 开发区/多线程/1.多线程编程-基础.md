## 多线程编程-基础

#### Java 中创建线程方式主要有三种：

1.继承 Thread 类，重写run() 方法，在run() 方法里实现内部逻辑
2.实现 Runnable 接口， 重写 Runnable 接口中的 run 方法，在 thread 类中传入 Runnable对象
3.实现 Callable 接口，重写 call() 方法，和 Future 来创建线程



#### Callable 和 Runnable 接口区别：

1.Runnable 不会产生任何返回值, Callable 有返回值
2.Callable重写 call 方法，而 Runnable 重写 run 方法。
3.使用 Callable 中的 call方法可以抛出异常，而 Runnable 方法不能抛出异常

**使用：**
执行 Callable方式，需要 FutureTask 实现类的支持，用于接收运算结果

```java
ThreadDemo td = new ThreadDemo();
FutureTask<Integer> result = new FutureTask<>(td);
Integer sum = result.get();
class ThreadDemo implements Callable<Integer> {..其中实现call() 方法..}
```



#### 可重入锁：

1. 同一个线程可以反复获得同一把锁，但申请和释放锁的次数必须一致。
2. 重入锁是非公平的，公平的重入锁性能差
3. 重入锁内部基于CAS实现的
4. 对于重入锁，可以使用 Condition类提供的await()，singal()功能，实现线程间通信
可重入锁优势：可以避免一些死锁的情况，更好的封装
可重入性：Synchronized 锁对象时，对象头关联的monitor中有个计数器，会记录下线程获取锁的次数，获得锁+1，释放锁-1，当计数器清零时就释放锁。

**不可中断性：**一个线程获取锁后，另一个线程处于阻塞或等待状态，前一个不释放，后一个则会一直阻塞或等待，不可以被中断。



#### 对象在 JVM 的内存中分为三块区域：

**1.对象头**
    * Mark Word（标记字段）：锁标志位信息…随着锁标志位的变化而变化。
        * Klass Point（类型指针）：指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。
        **2.实例数据：**存放类的数据信息，父类的信息。
        **3.对其填充：**虚拟机要求对象起始地址必须是 8字节的整数倍，为了字节对齐。
        问题：一个空对象占多少个字节？  8个字节，因为对齐填充的关系，不到8个字节对其填充会自动补齐。
        对象头关联一个monitor对象，当进入一个方法的时候，会获取当前对象的所有权，monitor进入数 +1，当前线程拥有 monitor的所有权。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmhszvufj60ys0f8dhk02.jpg" alt="3ECABF01-27BC-4FA1-8040-EB893F1B8E08" style="zoom:50%;" />



### Synchronized锁：

​		在 JDK1.6之前，Synchronized 属于重量级锁，效率低。 JDK1.6之后，Synchronized 锁升级的过程：无锁、偏向锁、轻量级锁、重量级锁。随着竞争的激烈而逐渐升级，注意：锁可以升级不可降级，为了提高获得锁和释放锁的效率。
从无锁状态，首先进入的线程获得偏向锁，当前释放后，此时如果同一个线程再次获得锁，锁不升级，偏向于同一线程；此时如果其他线程获得锁，并产生锁的竞争，则将锁升级为轻量级锁。
**偏向锁:** 采用CAS操作，每次同一线程进入，虚拟机就不进行任何同步操作，对标志位+1，不同线程过来，CAS操作失败。
**CAS操作：**jvm会存储 锁对象Mark Word 拷贝，然后利用 CAS比较当前的Mark Word和保存的Mark Word，相同就说明加锁成功，改变锁标志位
**轻量级锁（自旋锁）**：升级到轻量级锁后，同样也使用CAS操作判断。如果同一线程，CAS成功修改monitor中计算器+1。如果CAS操作失败，则自旋，一旦可以获取资源，就直接尝试成功，直到超出自旋阈值（10）。则自旋失败，升级为重量级锁，像1.5一样，等待唤醒。

轻量级锁通过不断自旋，来防止线程被挂起；线程等待唤醒 是 用户态和内核态 的切换，此过程很耗资源，可通过自旋减少这种消耗(短时间)

#### synchronized三种使用方式：

1.修饰实例方法:  在当前对象实例上加锁，进入同步代码前要获得当前对象实例的锁
2.修饰静态方法:  给当前类加锁，会作用于类的所有对象实例。
3.修饰代码块: 指定加锁对象，对给定的对象进行加锁，进入同步代码库前，先要获得 给定对象的锁。

#### 总结： 

synchronized关键字加到 static 静态方法和 synchronized(class) 代码块上都是给 Class 类上锁
synchronized 关键字加到 实例方法上是给 对象实例上锁
尽量不要 synchronized(String a) ，因为JVM中字符串常量池具有缓存功能！

#### synchronized和 ReentrantLock 的区别 （都是可重入锁）：

**1.层次：**synchronized是 JVM层面，ReentrantLock是 API层面。synchronized由jvm负责加锁，释放锁等操作，不需要我们维护；RentrantLock 是需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成
**2.中断:**  synchronized是不可中断的，ReentrantLock 是可中断的，通过 lock.lockInterruptibly() 实现，可以使正在等待的线程选择放弃等待
**3.指定公平锁，非公平锁：**synchronized只有非公平锁；ReentrantLock 可以通过参数设置公平，非公平锁。
**4.选择性通知（锁可以绑定多个条件）：**synchronized关键字与 wait()和 notify()/notifyAll()方法相结合可以实现 等待/通知机制，但被通知的线程是由 JVM 选择无法控制，如果执行 notifyAll()方法会通知所有处于等待状态的线程； 用 ReentrantLock类结合 Condition实例可以实现“选择性通知” ，Condition 可以为不同线程 注册不同的 Condition实例，执行 Condition实例的 signalAll()方法时 只会唤醒注册在该Condition实例中的所有等待线程。

**Synchronized 不可逆问题：**
例：我现在是滴滴，早上有打车高峰，代码使用了大量的synchronized，锁升级过程是不可逆的，过了高峰我们还是重量级的锁，那效率降低。根据具体场景进行选择



#### Volatile : 可见性、有序性

​		所有共享变量都存储于主内存，线程对变量的操作(读，取)是在 工作内存中完成的，而不是直接读写主内存中的变量。不同线程之间不能直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存中转来完成。 工作内存和主内存的关系：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmicl077j60ys0l6myk02.jpg" alt="C9F41EFB-5F43-4386-80D2-396863EAC7D4" style="zoom:50%;" />


​		多个处理器运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那同步回到主内存时以谁的缓存数据为准呢？为解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI等。

**MESI（缓存一致性协议）：**当 CPU写数据时，如果发现操作的变量是共享变量，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，就会从内存重新读取。
**加锁可以解决可见性问题：**某一个线程进入 synchronized代码块，线程获得锁，会清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码后，将修改后的 副本值刷新回主内存中，线程释放锁。而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。

**Volatile修饰的共享变量：**volatile使用缓存一致性协议，当一个线程修改了volatile修饰的变量，立即修改写回主内存，同时发信号通知其他线程将该变量的 缓存行置为无效状态，当其他线程需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，就会从内存重新读取，得到最新数据。

**怎么发现数据是否失效呢？**

嗅探： 每个处理器通过 嗅探在总线上传播的数据来检查自己缓存的值是不是过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前自己的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

##### 总线风暴：由于Volatile的 MESI缓存一致性协议，需要不断的从主内存嗅探和 cas 不断循环，无效交互会导致总线带宽达到峰值。 所以不要大量使用Volatile。



##### 有序性：禁止指令重排序

什么是重排序?  为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如 指令重排序导致的多个线程操作之间的不可见性

如何保证不会被重排序呢？**内存屏障**

Volatile借助Java编译器，在 生成指令系列时的适当位置插入 内存屏障 指令，来 禁止特定类型的处理器重排序。
Volatile 写：在前面和后面分别插入内存屏障； 而volatile读：在后面插入两个内存屏障。 

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmjarwfnj60na0iw3zq02.jpg" alt="68623192-B95E-4B38-BC96-08E01C1252D1" style="zoom:60%;" />

**Volatile 无法保证原子性**
要实现原子性操作，可以考虑加锁、原子类，比如 AtomicInteger；

#### volatile与synchronized的区别:

1.volatile只能修饰 变量（实例变量、类变量），而 synchronized可以修饰 方法，以及代码块。
2.volatile保证数据的可见性，但不保证原子性(多线程同时进行写操作，不保证线程安全);  synchronized 两者都能保证。
3.volatile 主要解决变量在多个线程之间的可见性，而 synchronized主要解决多线程之间访问资源的同步性。
4.多线程访问 volatile不会发生阻塞，而synchronized 可能会发生阻塞。

volatile可以看做是轻量版的synchronized，volatile不保证原子性。
如果一个共享变量进行多个线程的赋值，没有其他操作，那可以用volatile来代替synchronized，因为赋值本身是原子性的，而volatile又保证可见性，所以可以保证线程安全。

#### 使用场景：

1. 某个属性被多个线程共享，其中一个线程修改后，其 他线程可以立即得到修改后的值
2. volatile提供可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。
3. volatile可以使得 long和double的赋值是原子的。
4. Volatile可以在 单例双重检查中实现可见性和 禁止指令重排序，从而保证安全性。

Volatile 禁止指令重排序好处:  创建对象需要几个步骤：

1.分配内存空间;   2.调用构造器，初始化实例 ;  3.返回地址给引用

​        在执行时可能发生指令重排序，有可能 构造函数在对象初始化完成前就赋值完成，在内存里开辟一片存储区域后直接返回内存的引用，这个时候还没真正的初始化完对象。但是别的线程去判断 instance!=null，直接拿去用了，其实这个对象是个半成品，那就有空指针异常了。



### 常见的线程池种类：

**SingleThreadPool 单个线程：**若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
**FixedThreadPool 固定线程数量：**线程数量始终不变。当一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，新任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
**CachedThreadPool 动态分配线程数量：**根据具体的任务数量来调整线程数量的线程池，若有空闲线程可以复用，会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

#### 线程池的构建方法：

1.构造方法实现： ThreadPoolExecutor(6个参数)
2.使用 Executor 框架的工具类 Executors来实现

#### 线程池的参数，ThreadPoolExecutor 构造函数重要参数：

**1.corePoolSize :**  核心线程数，定义最小可以同时运行的线程数量。核心线程数，默认情况下，核心线程会一直存活，但是当将allowCoreThreadTimeout 设置为true时，核心线程也会超时回收。
**2.maximumPoolSize :**  当队列中存放的任务达到队列容量的时候，可以同时运行的线程数量变为最大线程数。
**3.workQueue:**  缓存队列当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务会被存放在队列中。
**4.keepAliveTime:** 当线程池中的线程数量大于 corePoolSize 时，此时如果没有新任务提交，核心线程外的线程 不会立即销毁，而是等待直到时间超过 keepAliveTime才会被回收销毁；
**5.unit :**  keepAliveTime 参数的时间单位。
**6.handler :** 饱和策略；当线程数量达到maximumPoolSize，并且workQueue中任务满时，执行饱和操作。

#### ThreadPoolExecutor 饱和策略：

1.ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。
2.ThreadPoolExecutor.DiscardOldestPolicy： 此策略将 丢弃最早的未处理的任务请求。
3.ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException 异常，拒绝新任务的处理。
4.ThreadPoolExecutor.CallerRunsPolicy：增加队列容量，调用执行自己的线程运行任务。如果应用程序可以承受此延迟并且不允许丢弃任何一个任务请求，可以选择。这种策略会降低对于新任务提交速度，影响程序的整体性能。

##### 阻塞队列：

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。
1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。
		阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。
**非阻塞队列：**入队和出队操作均利用CAS（compare and set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。
2.LinkedBlockingQueue可以高效的处理并发数据，这是因为生产者和消费者端分别采用了独立的锁来控制数据同步，所以在高并发的情况下生产者和消费者可以并行地操作队列中的数据，从而提高整个队列的并发性能。

3.如果没有给 LinkedBlockingQueue 指定其容量大小，则默认为 Integer.MAX_VALUE，这样的话，如果生产者的速度大于消费者的速度，则可能还没等到队列阻塞，系统内存就被消耗完了，从而导致内存溢出

参考：https://blog.csdn.net/xyy1028/article/details/107801358



#### 线程池中线程数量的设置：

CPU密集型的任务：较小线程数
IO密集型的任务：较多线程数
由于 IO操作不占用CPU，不能让CPU闲。但如果线程数目太多，线程切换所带来的开销也会对系统的响应时间带来影响。

线程等待时间所占比例越高，需要越多线程。线程CPU时间 所占比例越高，需要越少线程。

CPU 的使用率 50% （ 线程CPU时间/(线程等待时间+线程CPU时间）），那么这段时间可以运行 2 个IO任务
$$
最佳线程数目  = （（ 线程等待时间+线程CPU时间）/ 线程CPU时间 ）* CPU数目
$$


**Atomic 原子类 （一个操作是不可中断的）：**
AtomicInteger 类主要利用 CAS + volatile 来保证原子操作，避免 synchronized 的高开销，提升执行效率。

JUC 包中的4种 原子类：基本类型：AtomicInteger：整形原子类 等；数组类型：AtomicIntegerArray：整形数组原子类； 引用类型：AtomicReference：引用类型原子类；



#### 线程中常用的方法：

 .join() 方法（类似中断）： 导致当前运行的线程停止执行，直到它加入的线程完成其任务，调用 join 时带上一个超时参数，来设置到期时间，时间到期 join方法自动返回。类似于中断，先执行其他线程，再返回来执行原来这个。

#### execute() 和 submit() 的区别：

1. execute() 无返回值，无法判断任务 是否被线程池执行成功。
2. submit() 有返回值， 线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以 判断任务是否执行成功，并且通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成。



#### start(),  run() 区别：

1.调用 Thread.start( ) 方法启动一个线程，此线程是处于 就绪状态，并没有运行
2.然后通过此 Thread类来调用 run() 方法，完成其运行操作，run() 称为线程体，它包含这个线程要执行的内容，run()方法运行结束，此线程终止，之后CPU再运行其它线程。run()方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行后续代码。
如果直接用Run方法，这只是调用一个方法而已，程序中依然只有主线程--这一个线程，其程序执行路径还是只有一条，这样就没有达到多线程目的。
run() 只是在当前线程中执行任务，而 start才是 真正生成thread，并放在cpu中调度。

