## 多线程-详解知识点

#### **1. 线程:** 

是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存.



#### **2.  线程安全和线程不安全？**

**线程安全:** 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用, 不会出现数据不一致问题。

**线程不安全：**不提供数据访问保护，有可能出现 **多个线程先后更改数据** 造成所得到的数据是脏数据； 

线程安全问题 都是由 全局变量，静态变量引起的，若有多个线程同时执行写操作，一般需要考虑线程同步，否则可能影响线程安全。

**多线程：**是指从 软件或硬件上实现多个线程的并发技术。

#### 多线程的好处：

i. 使用 多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载

ii. 发挥 多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好

#### 多线程的缺点：

1.大量的 线程降低代码的可读性；

2.更多的 线程需要更多的内存空间

3.当 多个线程对同一个资源出现争夺时候要注意 线程安全的问题。



#### 3. ⾃旋锁

1.当线程 A 想要获取一把自旋锁⽽该锁又被其它线程锁持有时，线程 A会在⼀个循环中自旋以检测锁是不是已经可用。

**2.自旋锁需要注意：**

- 由于 自旋时不释放CPU，持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直自旋，浪费CPU时间。
- 持有自旋锁的线程在 sleep 之前应该释放自旋锁，以便其它线程可以获得自旋锁。

3.目前的 JVM实现自旋会 消耗CPU，如果⻓时间不调用 doNotify方法，doWait方法会一直自旋，CPU会消耗太大

4.自旋锁比较适用于 锁使用者 ，保持锁时间比较短 的情况，这种情况自旋锁的效率比较高

5.自旋锁是一种对 多处理器相当有效的机制，⽽在单处理器非抢占式的系统中基本上没有作⽤



#### 4. 乐观锁和悲观锁

**悲观锁：** 每次都加重锁，认为其他线程会访问共享变量

**乐观锁：** 轻量级的锁，认为其他线程不会访问共享变量，修改时进行判断，通过 cas 乐观锁技术 保证数据⼀致性。

#### **5. 原⼦操作** 

在 Java Concurrency API中有些原⼦类(atomic classes)

原子操作：一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的⼿段。

int++： 并不不是一个原子操作，所以当⼀个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。

解决问题：**java.util.concurrent. atomic** 包提供了int和long类型，它们可以自动的保证操作是原子的并且不需要使用同步。



#### **6.** Executors框架

Java通过 Executors 提供四种线程池，分别为：

1.newSingleThreadExecutor 创建一个单线程线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行

2.newFixedThreadPool 创建一个固定数量线程池，可控制线程最大并发数，超出的线程会在队列中等待。

3.newCachedThreadPool 创建一个可缓存线程池，如果 线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

4.newScheduledThreadPool 创建一个定⻓线程池，支持 定时及周期性任务执行。



#### **7. 阻塞队列**

 JDK7 提供了 7个阻塞队列（也属于并发容器）

1. ArrayBlockingQueue ：一个由 数组结构组成的 有界阻塞队列
2.  LinkedBlockingQueue ：一个由 链表结构组成的 有界阻塞队列
3. PriorityBlockingQueue ：一个 支持优先级排序的 无界阻塞队列。
4. DelayQueue：一个使用 优先级队列实现的 无界阻塞队列。
5. SynchronousQueue：一个不存储元素的 阻塞队列。
6. LinkedTransferQueue：一个由链表结构组成的 无界阻塞队列。
7. LinkedBlockingDeque：一个由链表结构组成的 双向阻塞队列。

**概念：** 阻塞队列 是一个在队列基础上又支持 两个附加操作的队列。

附加操作：

支持阻塞的 插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。

支持阻塞的 移除方法：队列空时，获取元素的线程会等待队列变为非空。



#### **8. Callable和Future**

获取线程的执行结果时使用，Callable 用于产生结果，Future用于获取结果；

Callable 接口使用 泛型去定义它的返回类型，Executors 类提供一些有用的方法在线程池中执⾏Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。

在线程池提交Callable任务后返回一个Future对象，使用它可以知道 Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。



#### **9. FutureTask**

FutureTask 可用于 异步获取执行结果或取消执行任务的场景。

通过传入Runnable或 Callable的任务给 FutureTask，直接调用其 run方法或放入线程池执行，之后可以在外部通过 FutureTask的 get方法异步获取执行结果，因此 FutureTask 非常适合⽤于耗时的计算，主线程可以在完成⾃己的任务后，再去获取结果。另外，FutureTask还可以确保 即使调用多次 run方法，它都只会执行一次 Runnable或 Callable任务，或通过 cancel 取消 FutureTask的执行等。

FutureTask 可用于执行 多任务、以 避免高并发情况下多次创建数据锁的出现。



#### **10. 同步容器 和 并发容器**

同步容器：

- 主要代表有 Vector和 Hashtable，以及 Collections.synchronizedXxx等；
- 锁的 粒度为当前对象整体；
- 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛ConcurrentModificationException。

并发容器：  

- 主要代表有 ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。

- 锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。

- 迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。

  

#### **11. 多线程的上下文切换**

CPU 通过 时间片分配算法来循环执行任务，当前一个任务执行一个时间片后，会切换到下一个任务。但在切换前会保存上一个任务的状态，以便下次 切换回这个任务时，可以再次加载这个任务的状态。



#### **12.ThreadLocal的作用**

​        ThreadLocal 类允许 创建 只能被同一个线程读写的变量。因此，如果⼀段代码含有一个 ThreadLocal变量的引用，即使 两个线程同时执行这段代码，它们也 无法访问到对方的ThreadLocal变量量。

**线程局部变量:**  在并发编程的时候，成员变量如果不做任何处理, 线程是不安全的，各个线程都在操作同⼀个变量，显然是不行的，volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，需要满足这样⼀个条件：变量是同一个，但每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下 ThreadLocal就⾮常适用，比如说 DAO的数据库连接，DAO是单例的，它的属性 Connection 就不是一个线程安全的变量。每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。

​		每个线程都维护了一个map，而这个map的 key就是 threadLocal，而值就是我们set的那个值，每次线程在 get的时候，都从⾃己的变量中取值，既然从⾃己的变量中取值，那肯定就不存在线程安全问题。ThreadLocal这个变量的状态根本没有发生变化，他仅是充当一个 key的⻆色，另外提供给每一个线程一个初始值。



#### **13. ThreadPool（线程池）用法与优势**

优点：

1.减少 创建和销毁线程的次数，每个工作线程都可以被重复利用，可执⾏多个任务

2.可以根据系统的承受能力，调整 线程池中工作线程的数目，防⽌因为消耗过多的内存，而把服务器累趴下

(每个线程需要⼤约 1MB内存，线程开的越多，消耗的内存也就越大，最后死机)；减少在 创建和销毁线程上所花的时间以及系统资源的开销

如不使⽤用线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存

Java⾥⾯线程池的顶级接口： Executor，但严格意义上讲 Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具，真正的线程池接⼜是 ExecutorService。

- 当线程数 < corePoolSize时，创建线程执⾏行行任务。
- 当线程数 >= corePoolSize并且 workQueue没有满时，放入workQueue中
- 线程数  >=corePoolSize并且 workQueue满时，新任务**新建线程运行**，线程总数要 < maximumPoolSize
- 当线程总数 =maximumPoolSize并且 workQueue满了的时候，执行 handler的rejectedExecution 拒绝策略



#### **14.CAS 产生的ABA 问题**

原节点 A ，改变头节点 2次， 先改为 B， 改变B 指针的指向（插入链表的表头，成为新头节点），最后再改回节点 A ，对于节点，其实际的 值没有改变，但此时 指针的指向 已经发生了改变

解决：

加入版本号，在内部维护一个状态戳（时间戳），每次修改对象值的同时，也改变状态戳，

在校验 CAS 时，同时校验  对象值+ 状态戳 的期望值（类似于MVCC 中记录数据的版本号操作）



#### **15. volatile关键字作用**

*从主内存中加载 最新的数据

*对共享变量修改后，立刻重写回主内存，即时刷新重写

*为了获取更好的性能 JVM可能会对指令进行重排序，volatile则会对 禁⽌语义重排序



------------------------------------------------------------------------------------------------------------------------------------------------------



#### **1. 如何获取 线程 dump(堆栈)⽂件**

线程 dump 堆栈； 死循环、死锁、阻塞、⻚面 打开慢等问题，查看线程 dump是最好的解决问题的途径。

获取到线程堆栈有两步：

1.获取到线程的 pid，通过 ps命令， ps -ef | grep java

2.打印线程堆栈，通过 jstack pid 命令，在 Linux环境下还可以使⽤用 kill -3 pid

3.Thread类提供了一个 getStackTrace()方法， 可以获取线程堆栈。此方法和具体线程实例绑定，每次获取到的是某个线程当前运行的堆栈。



#### **2. 创建 线程的方式**

- 继承 Thread类，重写 run方法
- 实现 Runnable接口并重写 run方法，实现Runnable接口实现类的实例对象，作为Thread构造函数的target
- 实现 Callable接口，通过 FutureTask包装器来创建Thread线程
- 通过 线程池创建线程



#### **3.多线程线程数量设置**

A. 高并发、任务执行时间短的业务： 线程池线程数可以设置为 CPU核数+1，减少线程上下⽂的切换。

B. 并发不高、任务执行时间长的业务：

*假如是业务时间长集中在 IO操作上，也就是 IO密集型的任务，因为IO操作并不占⽤用CPU，所以不要让所有的CPU 闲下来，可以加⼤线程池中的线程数目，让CPU处理更多的业务

*假如是业务时间长集中在计算操作上，也就是 计算密集型任务，这个就没办法了，和 (1)一样，线程池中的 线程数设置得少一些，减少线程上下文的切换

C. 并发高、业务执行时间长：解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，

第一步：看这些业务⾥面 某些数据是否能做缓存

第二步：增加服务器 

第三步：使用 中间件 对任务进行 拆分和解耦



#### **4. 锁的等级：方法锁、对象锁、类锁**

1.方法锁，synchronized修饰方法时

a. 通过在 **方法声明中加入 synchronized 关键字**来声明 synchronized 方法。

b. synchronized 方法控制对 类成员变量的访问：

c. 每个 类实例对应一把锁，每个 synchronized 方法都必须获得 调用该方法的 类实例的锁 方能执行，否则所属线程阻塞，⽅法一旦执行，就独占该锁，直到 从该方法返回时才将锁释放，此后被 阻塞的线程方能获得该锁，重新进⼊可执行状态。

这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从⽽有效避免了类成员变量的访问冲突。

2.对象锁，synchronized修饰方法或代码块

a. 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，必须先获得对象锁。如果对象锁已被其他调用者占用，则需要等待此锁被释放。（⽅法锁也是对象锁）

b. java的所有对象都含有 1个互斥锁，这个锁由 JVM自动获取和释放。线程进入 synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会⾃动释放对象锁。这里也体现了用 synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来自动释放。

3.类锁(synchronized 修饰静态的方法或代码块)

a. 由于一个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有一份。所以，一旦一个静态的⽅法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为 类锁。

4.对象锁 是用来控制实例方法之间的同步，类锁 是用来 控制静态方法（或静态变量互斥体）之间的同步

总结：

1. 在某个对象的所有synchronized方法中,在某个时刻只能有一个唯一的一个线程去访问这些synchronized方法

2. 如果一个方法是synchronized方法,那么该synchronized关键字表示给当前对象上锁(即this)相当于

synchronized(this){}

3. 如果⼀个synchronized方法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管生成多少对象,其对应的class对象只有⼀个)

   

#### **5.并行、并发的区别**

1. 并行指两个或多个事件在同一时刻发生； 并发指两个或多个事件在 同一时间间隔发生。

2. 并行 是在不同实体上的多个事件，并发是在 同一实体上的多个事件。

3. 并行是在多台处理器上同时处理多个任务；并发是在一台处理器上“同时”处理多个任务。

并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能



#### **6.唤醒一个阻塞的线程**

wait与notify：wait与notify 配合synchronized使用，调用之前持有锁，wait会立即释放锁，notify同步块执行完才释放。

await与singal：Condition类提供，由 new ReentLock().newCondition() 获得Condition对象，与 wait和 notify相同，因为在使用 Lock锁后无法使用wait方法。

park与 unpark：LockSupport 是一个线程阻塞工具，可以在 线程任意位置让线程阻塞。和 Thread.suspenf()相比，它弥补了由于 resume() 在前发生，导致线程⽆法继续执行的情况。和Object.wait()相⽐，它 不需要先获得某个对象的锁，也不会抛出 IException异常。可以唤醒指定线程。



#### **7. 如何检测死锁，预防死锁**

死锁：两个或两个以上的进程在执行过程中，因 争夺资源而造成一种互相等待 的现象，若无外力作用，它们都将⽆法推进下去。

产生死锁必要条件：

1. 互斥条件：进程对所 分配到的资源 不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至释放该资源

2. 请求和保持：进程获得资源后，对其他资源发请求，但该资源可能被其他进程占有，此时请求阻塞，但它对已获得资源保持不放

3. 不可剥夺：进程 已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放

4. 循环等待：进程发⽣ 死锁后，若干进程之间形成⼀种 头尾相接的 循环等待资源关系

**死锁产生原因：**

1.竞争资源发⽣死锁：多个进程共享的资源数目不足以满⾜全部进程的需要，引起对资源的竞争

2.进程 推进顺序不当发⽣死锁



#### **8. 守护线程**

守护线程（daemon thread），是个服务线程，用于服务其他的线程

Java中线程分2种：

1.守护线程，⽐如 垃圾回收线程，最典型的守护线程

2.用户线程，应用程序里的自定义线程



#### **9. synchronized和ReentrantLock 区别**

**可重入锁：**同一个线程可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。

**可中断锁：**线程尝试获取锁的过程中，是否可以响应中断。synchronized 不可中断，ReentrantLock可中断

**公平锁：**  多个线程 同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，

**非公****平锁：**允许线程“插队”, synchronized：非公平锁，  ReentrantLock的默认：非公平锁，但可以设置为公平锁

Synchronized

Synchronized是  java内置的关键字，它提供了一种独占的加锁方式；Synchronized 的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。

局限性：

1. 当线程尝试获取锁的时候，如果 获取不到锁会一直阻塞。

2. 如果 获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。

ReentrantLock:

1. ReentrantLock它是JDK 1.5之后提供的 API层面的互斥锁，需要 lock() 和 unlock()方法配合 try/finally语句块来完成。

2. 等待可中断避免，出现死锁的情况

（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回 true，如果等待超时，返回false）

3. 公平锁与非公平锁 多个线程等待同一个锁时，必须按照 申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁

4. 选择性通知： Synchronized只能通过notify, notifyAll 随机唤醒一个或多个等待的线程； ReentrantLock可以和Contition实例配合，指定的线程注册到指定的Contition实例中，实现选择性唤醒。

   

#### **10. Lock接⼝(Lock interface)**

Lock 接⼝比同步方法和同步块提供更具扩展性的锁操作，他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持 多个相关类的条件对象。

优势：

可以使 锁更公平

可以使 线程在等待锁的时候响应中断

可以让 线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间

可以在 不同的范围，以不同的顺序获取和释放锁



#### **11. ConcurrentHashMap 并发度**

1、工作机制（分片思想）：它引入了一个 “分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的segment，

根据 key.hashCode()来决定把 key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

2、应用：当读 > 写时使用，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；

hash冲突：HashMap中调用 hashCode()方法计算hashCode。由于在Java中两个不同的对象可能有一样的

hashCode,  所以不同的键可能有一样hashCode，从而导致冲突的产生。

hash冲突解决：使用平衡树来代替链表，当同一hash中的元素数量超过 8 时会由链表切换到平衡树

无锁读：ConcurrentHashMap 有较好的并发性，因为 ConcurrentHashMap是 无锁读和加锁写，并且利用分段锁（不是在所有的entry上加锁，而是在一部分entry上加锁）；

ConcurrentHashMap的并发度就是 segment的⼤小，默认为16，这意味着最多同时可以有16条线程操作

ConcurrentHashMap，这也是 ConcurrentHashMap对Hashtable的最⼤优势。 JDK 1.7 后，ConcurrentHashMap 升级为 数组首节点加锁



#### **12. CyclicBarrier 和 CountDownLatch 区别**

CyclicBarrier  和  CountDownLatch 都位于  java.util.concurrent 这个包下

CountDownLatch:  减计数； 计算=0时释放所有等待线程； 计数为0后无法重置，不可重复利用； 调用countDown() 方法计数-1，调用await() 方法只进行阻塞，对技术没有任何影响。

CyclicBarrier:  加计数； 计数=指定值时，释放所有等待线程； 计数=指定值，计数置为0重新开始，可重复利用； 调用await() 方法计数+1， +1后< 指定值时，线程阻塞；



#### **13. Fork/Join作用**

1.Fork ： 把一个 大任务切分为若⼲子任务并行的执行。

2.Join ： 合并这些子任务的执行结果，最后得到这个⼤任务的结果。



#### **14. wait()和sleep() 区别** 

sleep()方法：  线程类（Thread）的静态方法，让调用 线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入 就绪状态和 其他线程一起竞争cpu的执⾏时间。

因为 sleep() 是 static静态的方法，它不能改变对象的锁，当一个 synchronized 块中调⽤ sleep()方法，线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象。

wait()方法：  Object类的方法，当一个线程执行到 wait方法时，它就进入到一个和 该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll⽅法来唤醒等待的线程



#### **15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）**

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg" alt="A810BC90-DA3F-4760-9FC7-7AD666F47AC6" width="650" height="300" />

1. 创建状态：生成线程对象，并 没有调用该对象的 start方法，这是线程处于创建状态。

2. 就绪状态：调用线程对象的 start方法之后，进入就绪状态，没有获得时间片则不会执行，从等待或睡眠中醒来，也会处于就绪状态

3. 运行状态： 线程调度程序将 就绪线程设置为当前线程，此时进入运行状态，开始运行 run()函数当中的代码。

4. 阻塞状态： 线程正在运行时被暂停，为等待某个事件的发生(资源就绪)之后再继续运行，sleep, suspend,wait等方法可以导致线程阻塞。

5. 死亡状态： 一个线程 run()方法执行结束或调用stop()方法后，该线程就会死亡，对于死亡的线程，无法再使用 start⽅法使其进入就绪。



#### **16. start()和 run()方法区别**

1.start()方法来 启动一个线程，真正实现多线程运行。

2.如果直接调用 run(), 其实就相当于是调用一个普通函数而已，直接调用 run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要使用 start()方法而不是run()方法。