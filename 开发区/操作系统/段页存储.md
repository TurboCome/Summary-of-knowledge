Linux 段，页存储：  https://blog.csdn.net/jinking01/article/details/107098437

#### 背景：

​		在多进程环境下，为使进程之间的内存地址不受影响，相互隔离，操作系统为 每个进程独立分配一套 虚拟地址空间，每个程序只关心自己的虚拟地址，多进程通过 虚拟地址 映射到不同的物理地址内存。

​		作为程序，也不用关心物理地址的事情。每个进程都有自己的虚拟空间，而物理内存只有一个；当启用大量的进程，物理内存必然会很紧张，于是操作系统会通过 内存交换技术，把不常使用的内存暂时存放到硬盘 （换出），在需要时再装载回物理内存（换入）。

​		有了虚拟地址空间，必然要把 虚拟地址「映射」到 物理地址，这个事情通常由操作系统来维护，对于虚拟地址与物理地址的映射关系，可以有 分段，分页，段页的方式。访问虚拟地址时，由操作系统转换成不同的 物理地址，这样不同进程运行的时候，写入不同的物理地址，就不会冲突。

程序所使用的内存地址： 虚拟内存地址
实际存硬件里面的空间地址：物理内存地址



### 内存分段  （Segmentation）

​		程序由若干个逻辑分段组成： 代码分段、数据分段、栈段、堆段；不同段 有不同的属性，用分段形式把这些段分离出来。

<<<<<<< HEAD
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurit4benyj612e0rwjt702.jpg" alt="F3F67004-8E73-43E9-9085-55FD89A5D40D" style="zoom:50%;" />
=======
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guri5bhi4xj612e0rwmyz02.jpg" alt="F3F67004-8E73-43E9-9085-55FD89A5D40D" style="zoom:30%;" />
>>>>>>> c86bb6eb0f35628a16f12b67bb15700c28c4a1d8

#### 内存分段-寻址方式

**段选择因子：**保存在段寄存器里；

**段号：**段表的索引，段表里面保存 段的基地址、段的界限和 特权等级等；

**段内偏移量：**位于（ 0  ~ 段界限）；  

物理内存地址 = 段基地址 + 段内偏移量； 虚拟地址：通过 段表与 物理地址映射，分段机制把程序的虚拟地址分成 4 个段，每个段在 段表中有一个项，在这一项找到段的基地址，再加上偏移量，就能找到物理内存中的地址。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guritaa78xj60tb0i3abv02.jpg" alt="255BA9F7-C651-478C-AC47-73750F6D3619" style="zoom:50%;" />



#### **段式存储问题：** 1.内存碎片；  2.内存交换的效率低

#### 1.内存锁片：

**外部内存碎片：**在物理内存中产生多个 不连续的小物理内存，导致 新的程序无法被装载；
**内部内存碎片：**程序所有的内存都被装载到物理内存，但程序 有部分的内存 可能并不是很常使用，这也会导致内存的浪费；

**内存交换：**解决--外部内存碎片问题
		把一个程序占用的 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回时，不装载回原来位置，而是紧紧跟在已经被占用的 512MB 内存后面。这样就 就使得空间利用连续，避免内存碎片产生。

#### 2.内存交换的效率低：

​		内存交换空间在 Linux 系统里就是 Swap 空间，这块 空间是从硬盘划分出来，用于内存与硬盘的空间交换 
对于多进程系统，内存碎片很容易产生，需要经常进行 内存交换操作，但Swap空间是硬盘，有性能瓶颈；硬盘访问速度比内存慢很多，每次内存交换都需要把 一大段连续的内存数据写到硬盘上。如果内存交换时，交换占内存空间很大的程序，整个机器都会卡顿。



### **内存分页：**

解决 内存碎片，内存交换效率低；把整个 虚拟，物理内存空间切成一段段 固定尺寸的大小-页（Page）：一个连续并尺寸固定的内存空间，Linux 一页大小 4KB。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guritehp2qj60tn0m575h02.jpg" alt="5724EB13-9A0A-4AA4-9C44-043EA8D0D3D0" style="zoom:50%;" />

虚拟地址分为： 页号，页内偏移
**页号：**页表的索引，页表包含 物理页每页所在 物理内存的基地址，物理内存地址 =  基地址 与 页内偏移的组合
内存分页寻址过程：
1.把虚拟内存地址，切分成 页号，偏移量
2.根据页号，从 页表里查询对应的物理页号
3.直接拿 物理页号 + 偏移量，得到 物理内存地址

**内存空间：**预先划分好，不像分段那样产生 间隙非常小的内存，这正是分段会产生内存碎片的原因。释放的内存都是以页为单位释放的，也不会产生无法给进程使用的小内存。
**页表：**存储在 CPU 内存管理单元 （MMU） 中；  CPU 可以直接 通过 MMU 找出实际要访问的 物理内存地址。
当 进程访问的虚拟地址在页表中查不到时，系统会产生：缺页异常
**解决：**进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurithpu25j61320nt76302.jpg" alt="C547F405-C521-41CA-AA71-DD30DC86D94F" style="zoom:50%;" />

​		如果内存空间不够，操作系统会把 其他正在运行的进程中的「最近没被使用LRU」的 内存页面换出（Swap Out）， 暂时写在硬盘上；需要时再加载进来，称为换入（Swap In）。一次性写入磁盘只有少数一个页或几个页，不会花太多时间，内存交换效率相对比较高。
​		分页方式在加载程序时，不需要一次性把程序加载到物理内存中。在虚拟内存 和物理内存的页映射之后，并不真的把页加载到物理内存里，而 只有在 程序运行中，需要用到对应虚拟内存页里面的 指令和数据时，再加载到 物理内存里面去。

#### 页式存储空间上的缺陷：

操作系统可以同时运行非常多的进程，意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，一个页大小 4KB，就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，整个 4GB 空间的映射就需要有 4MB 内存来存储页表。每个进程都是有自己的虚拟地址空间，如果有 100 个进程的话，就需要 400MB 内存来存储页表，这是非常大的内存，而 64 位环境则会更大。

**多级页表  解决：**多进程页表占用空间过大问题
使用 二级分页，一级页表 就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表，即可以在需要时才创建二级页表。例如：假设只有 20% 一级页表项被用到，那么页表占用内存空间就只有  4KB（一级页表）+  20% * 4 MB（二级页表）= 0.804MB

#### 局部性原理

​        每个进程有 4GB 虚拟地址空间，对于大多数程序来说，其使用的空间 远未达到 4GB，因为会有部分对应的页表项都是空的，没有分配，对于 已分配的页表项，如果是最近一段时间未访问的页表，在物理内存紧张的情况下，操作系统会将 页面换出到硬盘，不会占用物理内存。

**程序的局部性**
		把常访问的 几个页表项存储到访问速度更快的硬件，在 CPU 芯片中加入一个专门存放 程序最常访问的 页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为：页表缓存、转址旁路缓存、快表等。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guritkxemkj60s00e53zb02.jpg" alt="F2665293-6C21-4F33-8C0D-16EA3F0A15E9" style="zoom:50%;" />

#### 地址转换：

在 CPU 芯片里封装了 内存管理单元（Memory Management Unit）芯片，它用来完成 地址转换和 TLB 的访问与交互。CPU 在寻址时，会先查 TLB，如果没找到，才继续查常规的页表。TLB 命中率其实是很高的，因为程序最常访问的页就那几个 。



#### 段页式内存管理

内存分段和 内存分页并不是对立的，它们可以组合起来在同一个系统中使用，组合后称为：段页式内存管理
段页式内存管理：
1.先将程序划分为 多个有逻辑意义的段
2.再把 每个段划分为 多个页，对分段划分出来的连续空间，再划分 固定大小的页
这样地址结构就由 段号、段内页号，页内位移 三部分组成。用于 段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址 是 页表的起始地址，而 页表中的地址是 某页的物理页号 

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guritnvg2uj614c0jfdhy02.jpg" alt="431DF29B-F743-4129-B9C7-377E6C0D1DE8" style="zoom:50%;" />

**段页式地址 到 物理地址过程：**

1.访问 段表，得到 页表起始地址 
2.访问 页表，得到 物理页号 
3.将 物理页号 + 页内位移 组合，得到物理地址

Linux 虚拟地址和物理地址映射方式：
Linux 系统中，每个段都是从  0 地址开始的整个 4GB 虚拟空间（32 位），所有段的起始地址都是一样的。Linux 系统中的代码，包括操作系统本身的代码和 应用程序代码，所面对的 地址空间都是线性地址空间（虚拟地址），相当于屏蔽处理器中的 逻辑地址概念，段只被用于 访问控制和内存保护。
Linux 本身采用的实际是段式和页式都有，但不叫段页式； linux的 段和页式顺序的两个过程，只不过 段式相当于啥也不干，目的是为了保证兼容性，所以 Linux内存管理的方式实际上相当于 只有页式管理，但查询过程 经过一层段式查询。

#### 总结：

内存分段：
根据程序逻辑角度，分成 栈段、堆段、数据段、代码段 等，分离出不同属性的段，同时是一块连续的空间。
每个段的 大小都不是统一的，这会导致 内存碎片，内存交换效率低 的问题。
于是出现：内存分页
把 虚拟空间和 物理空间分成 大小固定的页，在 Linux 系统中每一页大小为 4KB。 
1.分页后就不会 产生细小的内存碎片。
2.在内存交换时，写入硬盘是 一个页或几个页，提高内存交换的效率。
多级页表：为解决 简单分页产生页表过大 问题，但会导致 CPU 在寻址过程中，需要 有很多层表参与，加大时间上的开销。
根据程序局部性原理，在 CPU 芯片中加入了 Cache 就是TLB（Translation Lookaside Buffer），负责 缓存最近常被访问的页表项，来提高 地址的转换速度。
Linux 系统主要采用 分页管理，但由于 Intel 处理器的发展史，Linux 系统无法避免 分段管理。于是 Linux 把所有 段的基地址设为 0，所有程序的地址空间都是 线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。
另外，Linxu 系统中 虚拟空间分布可分为用户态和内核态两部分，用户态：代码段、全局变量、BSS、函数栈、堆内存、映射区。
