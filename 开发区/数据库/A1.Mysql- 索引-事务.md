## Mysql: 索引-事务

### 搜索引擎：

**InnoDB :**   支持事务，外键，行锁（用MVCC支持高并发）；聚簇索引，叶子节点data域存行记录；跨平台copy 容易复制；Delete 表时一行一行删除
**MyIsAM:**  不支持 事务，外键，行锁；   非聚簇索引，叶子节点data域中存引用地址；   跨平台难 copy 不易复制； Delete表时先Drop 再Create； 

#### InooDB: 

InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。
默认级别时可重复读（REPEATABLE READ），在可串行化级别下，通过 MVCC + Next-Key Lock防止幻读。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwcf2dv8j60zk0hgmz202.jpg" alt="CB82D46E-3719-4F4B-BCC8-515631B077E7" width="650" height="300"  />



#### MyIsam索引：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwcox74fj60zo0moq6b02.jpg" alt="7814D4D9-4DD1-46A1-B96F-0E355B3B3D8C" width="650" height="400"  />



#### 索引优点：

1.提高数据检索的效率，降低数据库的 IO成本，类似于书的目录

2.索引列对 数据进行排序，降低数据排序的成本，降低CPU消耗

**被索引的列会 自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。如果按照 索引列的顺序进行排序，对应 order by语句来说，效率就会提高很多。

#### 索引缺点：

1.索引会占据磁盘空间 

2.索引虽然会 提高查询效率，但是会降低更新表的效率。每次对表增删改，不仅要保存数据，还保存或更新对应的索引文件。



#### 为什么索引结构使用B+树？

Hash :  不适合范围查找；无法用于排序与分组； 
二叉树：根节点的取值，容易导致 二叉树不分叉
平衡二叉树： 不支持 范围查询快速查找； 范围查询时需要从根节点多次遍历，查询效率不高。

**B树：** 
1.B树 不支持范围查询 的快速查找（节点保存记录）；  
2.每个节点的 data域存储 行记录，行的大小随着列数的增多，所占空间会变大。 这时一个 页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

**B+ 树：** 可以保证等值，范围查询的快速查找范围查询时，因为主键具备唯一性（后面不会有 <= max_val 数据），不需再向后查找，终止。
InnoDB存储引擎一次 IO读取一页（默认16K）的数据量，MySQL的数据存储在磁盘文件中，查询处理数据时，需先把 磁盘中数据加载到内存中，磁盘IO操作很耗时，所以优化重点就是 尽量减少磁盘 IO 操作。

**自适应Hash:**  InnoDB 存储引擎中，当某个 索引值被频繁使用时，会在 B+Tree 索引之上 再创建一个哈希索引，让 B+Tree 索引可以根据哈希值来快速查找。MySQL 会自动评估使用自适应索引是否值得，如果观察到建立哈希索引可以提升速度，则建立。
一般情况下 聚簇索引 == 主键索引，当一个表没有创建主键索引时，**InnoDB会 自动构建聚簇索引，规则如下：**                                                                                                                             1.在表上定义 主键 PRIMARY KEY，InnoDB 将主键索引用作聚簇索引                                                        
2.如果表没有定义主键，InnoDB会选择 第一个不为NULL的 唯一索引列  用作聚簇索引                                                      
3.如果以上两个都没有，InnoDB 使用一个 6 字节长整型的字段 ROWID字段构建聚簇索引，该 ROWID字段会在 插入新行时自动递增
 辅助索引： 聚簇索引之外的所有其他索引。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwdw8ihtj60we0u0n3r02.jpg" alt="8F527CD4-0314-4103-BB56-350BEB31EE6E" width="650" height="450"  />



#### 联合索引查询：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwed8u8zj60uj0u0jv602.jpg" alt="91A14DB9-9D64-45B1-9856-D319978A60B0" width="650" height="500"  />

#### 前缀索引：

​		MySQL 支持前缀索引，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，索引默认包含整个字符串
**优点：**使用前缀索引，定义好长度，就可以做到既节省空间，又不用 额外增加太多的查询成本。
有前缀索引的联合索引 一定要回表： 联合索引已包涵相关信息，还是会回表，因为有前缀索引，不确定到底是不是一个完整的信息。
就算是 www.aobing@mogu.com 一个完整的邮箱去查询，但无法判断后续是否有数据，不知道是否是完整的数据，所以需要回表去判断



**最左匹配原则：** 在条件允许的情况下 使用组合索引替代多个单列索引使用。
**组合索引最左匹配：**组合索引查询时，mysql 一直向右匹配直至遇到范围查询 ( >、<、between、like ) 停止匹配
**最左前缀匹配原则：** MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
**覆盖索引：** 使用辅助索引的时候，只可以拿到主键值，获取数据还需要再根据主键查询主键索引取到数据。在上面abc_innodb 表中的组合索引查询时，如果只需要 abc字段，则查询到组合索引的叶子节点就可以直接返回，不需要回表。like 模糊匹配支持索引，支持最左匹配原则； Like 要使索引生效，like后不能以%开头， like %字段名%、like %字段名 这类语句会使索引失效

索引列不能参与计算，尽量保持列“干净”：

```mysql
FROM_UNIXTIME(create_time) = '2016-06-06’ 
```

不能使用索引，原因：B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较

```mysql
优化：  create_time = UNIX_TIMESTAMP('2016-06-06')。
```



#### 复合（联合）索引设计原则

1.把 频繁使用的列、区分度高的列放在前面
2.将 范围查询的列放在复合索引的最后面，例如 idx_status_create_time
3.在 常需要作为 查询返回的字段上增加到联合索引中，在联合索引上增加一个字段而使用到覆盖索引，此时建议这种情况下使用联合索引

索引下推：在使用联合索引时

```mysql
select * from table 
where name like '敖%' and size=22 and age = 20;
```

语句在搜索索引树时只能用 “敖”，找到第一个满足条件的记录ID1，然后判断其他条件是否满足，比如 size等后续条件；
在 MySQL 5.6之前，只能从 ID1开始 一个个回表，到主键索引上找出数据行，再对比字段值。

**索引下推优化：** 可以在索引遍历过程中对 联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurweri27rj61460oitb502.jpg" alt="D09379CE-16A1-4F7B-A744-2B6187490384" width="380" height="230"  /><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutxtnqq4aj61460kqdi302.jpg" alt="B8C04824-68B1-4785-867E-04BA4A1AC274" width="380" height="230"  />



#### 唯一索引、普通索引区别：（核心 change buffer）

普通索引使用 change buffer, 唯一索引不适用 change buffer



#### 索引字段选取：

1.主键，外键
2.尽量保持自增，差异性大的字段
3.出现频率高，常在where子句中出现的字段 
4.小的字段（减少所占用的空间）



#### 破坏使用索引的场景：

1.索引列 有函数运算/ 运算
2.索引列有  !=   <>    not in    not exist
3.like `%刘`  百分号在前的索引
4.字符型索引列 
5.隐式类型转换 
select * from t where id = 1
如果 id 是字符类型的，1是数字类型的，explain会发现走全表扫描，根本用不上索引；
因为MySQL底层会对 比较进行转换，相当于加了 cast( id AS signed int ) 这样的一个函数，上面说过函数会导致走不上索引。



#### MySQL 联接方式：

1、内联接（ 使用  = ， < ，> 比较运算符）： 包括相等联接、自然联接
内联接使用比较运算符根据 每个表 共有的列的值 匹配两个表中的行。例如，检索 students和courses表中 学生标识号相同的所有行  

2、外联接：左向外联接、右向外联接、完整外部联接   
在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：     
1）LEFT  JOIN或 LEFT OUTER JOIN     
左向外联接的结果集包括  LEFT OUTER 子句中指定的左表的所有行，而不仅仅是 联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的 结果集行中右表的所有选择列表列均为空值 null       
2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN     
右向外联接是 左向外联接的反向联接, 将返回右表的所有行, 如果右表的某行在左表中没有匹配行，则将为左表返回空值 null      
3）FULL  JOIN 或 FULL OUTER JOIN   
完整 外部联接返回 左表和右表中的所有行。当某行在 另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   

3、自然连接(笛卡尔积) 返回左表中的所有行，左表中的每一行与右表中的所有行组合





#### 事务四大特性：  原子性，一致性，隔离性，持久性

**1.持久性：**保证事务 提交后不会因为宕机等原因导致数据丢失； redo log
**2.原子性：**语句要么 全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；undo log （回滚找到前版本数据）
**3.隔离性：**保证 事务执行尽可能不受其他事务影响；undo log 
**4.一致性：**事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障
InnoDB默认的隔离级别是RR，RR的实现主要基于 锁机制（包含next-key lock），MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）

Redo log 保证事务 持久性； undo log 保证事务原子性、隔离性



#### 持久性： redo log（重做日志）

InnoDB 作为存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool  中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会 定期刷新到磁盘中（这一过程称为刷脏）。Buffer Pool 的使用提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。
Redo log 解决这个问题：当数据修改时，除了修改 Buffer Pool中的数据，还会在 redo log记录这次操作；当事务提交时，会调用 fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是 预写日志，（WAL Write-ahead logging），所有 修改先写入日志，再更新到Buffer Pool，保证数据不会因MySQL宕机而丢失，从而满足持久性要求。
redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快？
主要有以下两方面的原因：
（1）刷脏是随机IO，因为每次修改的数据位置随机，但写 redo log是追加操作，属于顺序IO
（2）刷脏是以 数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而 redo log中只包含真正需要写入的部分，无效IO 减少。



#### 原子性：undo log （回滚日志）

undo log: 当 事务回滚时能够撤销所有已经成功执行的sql语句，当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行 失败或调用了rollback，导致事务需要回滚，可以利用undo log中的信息将数据回滚到修改之前的样子。
undo log属于逻辑日志： 记录的是 sql执行相关的信息，当发生回滚时，InnoDB 会根据undo log的内容 做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。



#### 隔离性：undo log

并发情形下事务之间互不干扰， 隔离性主要可以分为两个方面（读、写操作）：
1.锁： (一个事务) 写操作对(另一个事务)写操作；

2. MVCC： (一个事务) 写操作对 (另一个事务)读操作

   <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwfv4xltj61bk0e43zo02.jpg" alt="207BFD43-7158-4542-8CD9-87A50C94B083" width="650" height="200"  />

**未提交读：** 事务可以读取 其他未提交事务的执行结果
**已提交读：** 事务可以读取  已经提交事务所做的改变
**可重复读：** 同一事务在 多次读取数据时，可以读取到相同的结果
**可串行化：** 各个事务间串行执行， 在每个读数据行上加上共享锁。在这个级别，导致大量的超时现象和锁竞争。

**脏读：** 不同事务下，当前事务可以读取到 另外事务未提交的数据
**不可重复读：** 同一事务内 多次读取同一数据，读取到的数据是不一样的
**幻读：** 一个事务读取 某一范围的数据行时，另一个事务在该范围内 插入新行，当此事务再次读取范围内的数据行时，返回之前不存在的行。 幻读是一种特殊的不可重复读问题。



#### InnoDB 锁类型 : 

**行锁：**行锁则只锁定需要操作的数据，并发性能好 

**共享锁（S Lock）：** 共享锁可以和其他锁共存；
多个事务可以同时访问 同一数据，但 只能读不能修改
**排他锁（X Lock）：** 排他锁和其他锁不能共存；
一个事务获取一个数据行的排他锁，其他事务就不能再获取该行的 共享锁和排他锁，获取排他锁的事务可以对数据进行读取和修改。
有排他锁的数据行，其他事务不能修改此数据行，也不能通过 for update和 lock in share mode 锁的方式查询数据，但可以直接通过 select ...from...查询数据，因为 普通查询没有任何锁机制
读时加共享锁，其他事务可以并发读，但不能写； 写时加排它锁，其他事务不能并发写，也不能并发读

**Record Lock：**行记录锁；
**Gap Lock：**间隙锁，在索引记录间隙上的锁，在第一条索引记录之前，最后一条索引记录之后上的间隙锁；
**Next-key lock：**下键锁，上面2个锁的组合锁；


间隙锁（Gap锁）

在使用范围条件检索数据，请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于 键值在条件范围内但并不存在的记录，叫做 “间隙(GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是 间隙锁（GAP锁）

```mysql
SELECT c1 FROM t 
WHERE c1 BETWEEN 10 and 20 
FOR UPDATE;
```

字面上意思是锁住 10-15的数据，如果id=10的数据已存在，那么别的用户 不可以修改该条数据，但是如果 id=15的数据并不存在，也是不可以插入的，因为无论该列中是否已有这样的值，因为该范围中 id 在 （10，15）所有 现有值之间的间隙也是锁定的。

#### 间隙锁的目的：

1.防止幻读，满足相关隔离级别的要求，要是不使用间隙锁，其他事务插入(10,20)闭区间的任何记录，本事务再次执行上述语句，就会发生幻读
2.为满足其恢复和复制的需要，有关其恢复和复制机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。

**Record Lock：** 锁定一个 记录上的索引，而不是记录本身；
**Gap Lock：**锁定索引之间的间隙，但不包含索引本身。

当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：

```mysql
SELECT c FROM t 
WHERE c BETWEEN 10 and 20 
FOR UPDATE;
```

**Next-Key Lock：** Record Locks + Gap Locks 结合，不仅锁定 一个记录上的索引，也锁定索引之间的间隙。

一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```mysql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

#### 间隙锁作用：

​		当事务A执行 update user set name='风筝2号’ where age = 10 时，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷, 10]， (10,30] 这两个区间加了间隙锁，从而导致事务 B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age<10， 10<age<30 记录页无法完成，而 >= 30的记录不受影响，这足以解决幻读问题了.
这是有索引的情况，如果 age 不是索引列，那数据库会为整个表加上间隙锁，不管 age 是否 >= 30，都要等待事务 A提交才可以成功插入.
​    

#### 表锁：表锁在操作数据时会锁定整张表，并发性能较差；

**意向共享锁（IS Lock）：**事务对 一张表中 某几行的数据加上共享锁；

**意向排他锁：** 事务对一张表中 某几行的数据加上 排他锁；
一个事务想要给一张表加上表锁，前提是 没有其他任何事务已经锁定这张表的任意一行数据，需要去全表扫描，确认是否有哪一行数据被其他事务锁定，但这非常低效。因此引入意向锁，意向锁相当于一个标识，表示 是否有其他事务 锁定该表中的某几行数据。





**未提交读 ：**  总是 读取最新的数据行，没有任何加锁，更新数据就会被读取到
**可串行化：**  MVCC + Next-Key Lock（Record Lock + Gap Lock）所有 读取的行都加锁

#### **已提交读：**   

根据 MVCC 实现，事务每次查询开始时 都会生成一个独立的 ReadView
在数据库表中看到的一行记录可能有多个版本，每个版本记录除了有数据本身外，还有一个 表示版本的字段（row trx_id），它在事务开始的时候向事务系统申请，按时间先后顺序递增 
已提交读是  每次执行语句时都重新生成一次快照，可重复读在事务开始的时候生成一个当前事务全局性的快照

一个快照能够读到那些版本数据，要遵循以下规则：
1.当前事务内的更新，可以读到；
2.版本 未提交，不能读到；
3.版本 已提交，但是却在快照创建后提交的，不能读到；
4.版本 已提交，且是在快照创建前提交的，可以读到；

已提交读-可重复读：主要区别是在快照的创建上，可重复读仅在事务开始时创建一次， 已提交读每次执行语句时都重新创建一次

#### 对于已提交读-—-可重复读区别：

它们生成 ReadView的策略不同，已提交读每次查询时都会生成一个新的 ReadView，而可重复读每次查询都复用第一次生成的ReadView，ReadView中保存数据版本号。

#### **可重复读：**

InnoDB 存储引擎中，
1.SELECT 操作的不可重复读问题 通过 MVCC 得到了解决；

2. UPDATE，DELETE 的不可重复读问题通过 Record Lock 解决
3.INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决
根据 MVCC实现，只会根据事务中第一次查询时生成的 ReadView 



**MVCC：** 多版本并发控制（Multi-Version Concurrency Control）
InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 已提交读、可重复读 这两种隔离级别。 

版本号：
**系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增
**事务版本号：事务开始时的系统版本号

隐藏的列： MVCC 在每行记录后面都保存着 两个隐藏的列，用来存储两个版本号
* 创建版本号：指示 创建一个数据行的快照时的系统版本号；
* 删除版本号：如果该快照的 删除版本号 > 当前事务版本号 表示该快照有效，否则表示该快照已经被删除

MVCC 使用 快照存储在 Undo 日志中，该日志通过 回滚指针把一个数据行（Record）的所有快照连接起来

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwgdnb4cj60yi0bcwf602.jpg" alt="856A41D0-5919-46E6-8477-421AFA8595D8" width="450" height="180"   />

#### 快照读、当前读：

问题：在可重复读级别中，通过 MVCC机制让数据变得可重复读，但读到的数据可能是历史数据，不是数据库当前的数据！
这在一些对于数据的 时效特别敏感 的业务中，可能出问题。
快照读： 读取历史数据； MVCC 的 select 操作是快照中的数据，不需要进行加锁操作。
当前读： 读取数据库当前版本数据； MVCC 对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行 加锁操作，从而读取最新的数据。

MVCC 也使用加锁，但是 避免了 SELECT 的加锁 , MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得 select不用加锁。
而 update，insert ，delete 这些 “当前读”的隔离性，就需要通过加锁来实现



未提交读隔离级别：直接返回记录上的最新值，没有视图概念，也就是图中丙丙那一栏，脏读，幻读，不可重复读都有可能发生。

串行化隔离级别： 直接用 加锁的方式来避免并行访问。 

已提交读、可重复读这两种隔离级别使用了MVCC：

事务在 执行普通的 SELECT操作， 访问记录版本链过程中，可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能

RC，RR 隔离级别不同： RC 在每一次进行 普通 SELECT操作前都会生成一个ReadView；

RR 只在第一次进行普通 SELECT操作前生成一个ReadView，数据的可重复读其实就是 ReadView的重复使用