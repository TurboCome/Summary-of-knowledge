## A2-Redis-持久化-哨兵/集群 

#### Redis 简介：

1.非常快
2.支持丰富的数据类型 
3.操作具有 原子性，单线程

#### 为什么快？

1.数据结构简单，操作的时间复杂度低
2.单线程，没有多线程相互切换的开销，避免不必要的上下文切换和锁竞争条件
3.所有操作都是基于内存的
4.多路I/O复用模型，非阻塞IO 

#### RDB：快照持久化 ，根据 指定时间内改变的key 数量来做持久化  （冷备）

快照持久化 完全交给 子进程处理，父进程 继续 处理客户端请求。
父进程调用 fork函数产生一个子进程 做数据持久化，不会修改现有的内存数据结构，只是对数据结构进行遍历读取，然后序列化写到磁盘中。但父进程继续响应客户端请求，然后对内存数据结构进行不间断的修改。
这个时候就会使用 操作系统的 COW 机制来进行 数据段页面 的分离。父进程对其中一个页面的数据进行修改时，将被共享的页面复制一份，并分离出来，然后对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，是一个快照的数据，然后子进程就可以遍历数据进行序列化写磁盘了。 

#### 优点：

1.性能影响小，网络传输快
2.数据恢复速度快
3.文件小

#### 缺点：

1.无法实时同步，停机时会导致大量丢失数据
2.兼容性差（文件需要满足指定格式）



### AOF ( Append Only File - 仅追加文件 ) 

​		将每条 写入命令作为日志，以 append-only 的模式写入一个日志文件中，这个模式是 只追加的，没有任何磁盘寻址的开销，速度快；先执行指令再将日志存盘。

每次执行 修改内存 中数据集的写操作时，都会 记录 该操作，在持久化恢复时 「重放」 所有的 修改性指令序列，来恢复 Redis 当前实例的内存数据结构的状态。AOF 是 先执行指令再将日志存盘，如果先写日志再操作的话，AOF日志中会出现 很多无效/错误的命令记录（一些错误的操作也会记录）对本来就庞大的AOF文件来说就是雪上加霜；这一点不同于 MySQL 等存储引擎，如果先存储日志再做逻辑处理，这样就可以保证即使宕机了，仍然可以通过之前保存的日志恢复到之前的数据状态；
AOF 文件采用追加写的方式，避免IO 的随机寻址，优化磁盘写入性能

#### 优点：

1.实时持久化，可以做到秒级更新（一秒一次去通过线程 fsync操作，最多丢一秒数据）；
2.文件兼容性好，无需满足指定格式；
3.文件写入性能快，文件不容易破损；

#### 缺点：

1.AOF 文件大；
2.恢复数据时对系统性能影响大； 
3.恢复速度慢；



#### 重写AOF 日志：

Redis 在长期运行的过程中，AOF 日志会越变越长，如果宕机重启，重放整个AOF日志会非常耗时，导致长时间Redis 无法对外提供服务，所以需要对AOF日志 “瘦身” 。Redis 提供 bg rewrite aof 指令用于对 AOF 日志进行瘦身；
**原理：**父进程开辟一个子进程，由子进程对内存中的 redis数据库进行遍历 转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件 中，序列化完毕后再将 操作期间发生的 增量AOF日志追加到这个新的 AOF日志文件中，追加完毕后就立即替代旧的AOF 日志文件

AOF 日志是以文件的形式存在的，当程序对AOF 日志文件进行写操作时，实际上是将内容写到 内核为文件描述符分配的一个内存缓存中，内核会异步将脏数据刷回到磁盘。

**出现事故时，第一时间用 RDB恢复，然后AOF做数据补全，冷备热备一起上。**

#### 突然机器掉电会怎样？

取决于AOF日志sync属性的配置，如果不要求性能，在 每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync是不现实的，一般都使用定时sync，比如1s 1次，这个时候最多丢失1s数据



#### 主从复制模型： 主从同步，从从同步

#### 主从之间数据同步：

1.第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到 内存buffer
2.完成后将 RDB快照文件 全量同步到复制节点，然后复制节点将RDB镜像加载到内存
3.加载完成后，再通知主节点将 期间修改的操作记录发送过来，复制节点重放这些操作记录
4.后续的 增量数据通过 AOF日志同步 
主从复制模型： 同时使用 RDB 、 AOF 持久化操作

#### 重点：

RDB快照数据生成时，缓存区也同时开始接受新请求，来保存同步期间的增量数据
传输过程中有什么网络问题，会自动重连，把缺少的数据补上
**优点：**高可用，提高数据读的负载能力
**缺点：**master 主节点故障，无法实现自动故障恢复

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkk6tseij610i0eidh802.jpg" alt="69DF28A0-0405-4D8E-95A3-6E028878273C" width="650" height="300" />





### 哨兵模型：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkkukxnlj60ci09mjrh02.jpg" alt="9EBF2504-8F59-45EA-BF6D-61EC4F8A8494" width="450" height="300" />

每个哨兵节点（Sentinal）每隔1秒向master、slave、其他哨兵节点发送 ping命令，如果对方能在指定时间内响应，说明节点健康存活。如果未在规定时间内（可配置）响应，那么该哨兵节点认为此节点 主观下线。

#### 故障恢复过程：

1.每个 Sentinal 节点  1次/s 向 它所关联的 主, 从 , 其他Sentinal 节点发送 ping命令，心跳检测
2.如果一个 节点没有回复 ping 命令，或超时， 将被Sentinal 节点标记为 主观下线
3.如果主节点被标记主观下线，与主节点相连的其他Sentinal 节点也监测主节点，当达到一定数量的Sentinal 节点都认为主节点下线了，主节点被标记为客观下线  
4.选举领导哨兵节点： 当主节点被判断客观下线以后，各个Sentinal 节点会进行协商，选举一个领导哨兵节点，并由该领导节点对其进行故障转移操作
监听该主节点的所有哨兵，都有可能被选为领导者，选举算法是 先到先得：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。 
5.故障转移：选举出的 领导者哨兵，开始进行故障转移操作，分 3个步骤：

#### 在从节点中选择新的主节点，原则: 

1.首先 过滤掉不健康的从节点； （下线或断线），没有回复过哨兵ping响应的从节点
2.然后 根据指定的优先级选择，默认情况下所有的从节点priority值为100，如果倾向于选择同机房的另一台salve节点替代现有的master节点，则可以把同机房的 从节点的 priority值设置的低一些
3.如果 优先级无法区分，则选择 复制偏移量最大的从节点；数据更新程度选择
4.如果仍无法区分，则选择 runid最小的从节点；每个节点启动的时候都会有一个唯一的runId
更新主从状态：通过 slaveof no one命令，让新选出来的从节点成为主节点；并通过 slaveof命令让其他节点成为其从节点，将已经下线的 主节点也设置为从节点。

每个哨兵都设置一个随机休眠时间，苏醒后向其他哨兵发送申请成为领导者的请求；其他哨兵只能对收到的第一个请求进行回复确认   ；首先达到多数确认选票的哨兵节点，成为领导者 Sentinal 节点数量是基数个，通过投票机制来 选出 leader 哨兵，如果当前 选不出来则重新进行投票。 每个Sentinal 节点会把 票投给第一个请求他的 Sentinal 节点 

Redis Sentinal 高可用，提高读负载，在 master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster 扩展性，提高写负载，在单个redis内存不足时，使用Cluster进行分片存储。 
**优点：** 在复制的基础上，实现自动故障恢复
**缺点：**写操作无法实现负载，存储能力受单机限制 （集群可解决）

### 集群模型：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkn395yzj60q90ext9y02.jpg" alt="D62740AC-71C8-49D7-97A9-D1644C0A2012" width="750" height="400" />

16384 =  2^14   
一致性hash ： 2^32 -1  
想扩展 并发读就添加Slaver，想扩展 并发写就添加Master，想扩容也就是添加Master，任何一个 Slaver或几个Master挂了都不会是灾难性的故障。
1.Redis集群是一个由 多个节点组成的分布式服务集群，具有复制、高可用和分片特性
2.集群没有中心节点，并且带有 复制和故障转移特性，不会因某个节点下线而影响整个集群
3.集群中的 主节点负责处理 槽（储存数据），而从节点则是主节点的 复制品
4.主节点只会执行自己槽有关的命令，当节点接收到不属于自己处理的槽的命令时，将会处理指定槽节点的地址返回给客户端，而 客户端会向正确的节点重新发送

各个哨兵模型下 slaver 间相互监听，若有故障随时替换，故障恢复
各个 master节点间均分数据分片，当 添加节点，删除节点时，由一致性Hash算法维护
现在 服务器都是多核的，如何高效使用 Redis?      通过在单机开多个Redis实例
集群中，各个master 节点保存 其他master 的数据槽范围，当出现 数据请求不在当前范围时，返回给 客户端并告诉其应该访问的具体master的  ip 信息。

#### 解决单机 Redis 的瓶颈？

**集群部署方式：** Redis cluster； 主从同步读写分离，类似Mysql的主从同步，Redis cluster 支撑 N 个 Redis master node，对数据分片，每个master node都可以挂载多个slave node。整个Redis 可以横向扩容，如果要支撑更大数据量的缓存，那就横向扩容更多的master 节点，每个master 节点能存放更多数据。

